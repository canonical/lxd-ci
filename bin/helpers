
# waitSnapdSeed: wait for snapd to be seeded.
waitSnapdSeed() (
  set +x
  for i in $(seq 60); do # Wait up to 60s.
    if systemctl show snapd.seeded.service --value --property SubState | grep -qx exited; then
      return 0 # Success.
    fi

    sleep 1
  done

  echo "snapd not seeded after ${i}s"
  return 1 # Failed.
)

# waitVMAgent: waits for the VM agent to be running.
waitVMAgent() (
  set +x
  vmName="${1}"
  instProj="${2:-}"
  if [ -z "${instProj}" ]; then
    # Find the currently selected project.
    instProj="$(lxc project list -f csv | sed -n 's/^\([^(]\+\) (current),.*/\1/ p')"
  fi

  for i in $(seq 90); do
    if lxc info --project "${instProj}" "${vmName}" | grep -qF 127.0.0.1; then
      return 0 # Success.
    fi

    sleep 1
  done

  echo "VM ${vmName} (${instProj}) agent not running after ${i}s"
  return 1 # Failed.
)

# waitInstanceReady: waits for the instance to be ready.
waitInstanceReady() (
  set +x
  maxWait=90
  instName="$1"
  instProj="${2:-}"
  if [ -z "${instProj}" ]; then
    # Find the currently selected project.
    instProj="$(lxc project list -f csv | sed -n 's/^\([^(]\+\) (current),.*/\1/ p')"
  fi

  if hasNeededAPIExtension instance_ready_state; then
    for _ in $(seq "${maxWait}"); do
      if lxc info --project "${instProj}" "${instName}" | grep -qF "Status: READY"; then
        return 0 # Success.
      fi

      sleep 1
    done
  elif lxc exec --project "${instProj}" "${instName}" -- timeout "${maxWait}" cloud-init status --wait >/dev/null; then
    return 0 # Success.
  fi

  echo "Instance ${instName} (${instProj}) not ready after ${maxWait}s"
  lxc list --project "${instProj}" "${instName}"
  return 1 # Failed.
)

# setupCloudInitReady: setup a cloud-init script to signal readiness.
setupCloudInitReady() {
  if ! hasNeededAPIExtension instance_ready_state; then
    echo "Missing needed extention for instance readiness, will wait for cloud-init instead"
    return 0
  fi

  instProj="${1}"
  profile="${2:-default}"

  lxc profile set "${profile}" --project "${instProj}" cloud-init.user-data - << EOF
#cloud-config
write_files:
  - content: |
     #!/bin/sh
     exec curl --unix-socket /dev/lxd/sock lxd/1.0 -X PATCH -d '{"state":"Ready"}'
    path: /var/lib/cloud/scripts/per-boot/ready.sh
    permissions: "0755"
EOF
}

# enableSRIOV: enable SR-IOV on a NIC.
enableNICSRIOV() (
  set +x
  parentNIC="${1}"
  numVFS="${2:-"7"}"

  echo "${numVFS}" > "/sys/class/net/${parentNIC}/device/sriov_numvfs"
  ip link set "${parentNIC}" up
  sleep 10
  ethtool "${parentNIC}"
)

# install_lxd: install LXD from a specific channel or `latest/edge` if none is provided.
install_lxd() (
    # Wait for snapd seeding
    waitSnapdSeed

    snap remove lxd || true
    snap install lxd --channel="${LXD_SNAP_CHANNEL:-"latest/edge"}"
    snap list lxd
    uname -a
    cat /proc/cmdline
    lxd waitready --timeout=300
)

# hasNeededAPIExtension: check if LXD supports the needed extension.
hasNeededAPIExtension() (
    needed_extension="${1}"

    lxc info | sed -ne '/^api_extensions:/,/^[^-]/ s/^- //p' | grep -qxF "${needed_extension}"
)

# runsMinimumKernel: check if the running kernel is at least the minimum version.
runsMinimumKernel() (
    min_version="${1}"
    min_major="$(echo "${min_version}" | cut -d. -f1)"
    min_minor="$(echo "${min_version}" | cut -d. -f2)"
    running_version="$(uname -r | cut -d. -f 1,2)"
    running_major="$(echo "${running_version}" | cut -d. -f1)"
    running_minor="$(echo "${running_version}" | cut -d. -f2)"

    if [ "${running_major}" -lt "${min_major}" ]; then
        return 1
    elif [ "${running_major}" -eq "${min_major}" ] && [ "${running_minor}" -lt "${min_minor}" ]; then
        return 1
    fi
    return 0
)

# cleanup: report if the test passed or not and return the appropriate return code.
cleanup() {
    echo ""
    if [ "${FAIL}" = "1" ]; then
        echo "Test failed"
        exit 1
    fi

    echo "Test passed"
    exit 0
}

FAIL=1
trap cleanup EXIT HUP INT TERM
